package effectivejava.chapter4.item19;

public class InheritanceDesignDoc {

    /*
     * 要么为继承而设计，并提供文档说明，要么就禁止继承
     * 首先，该类的文档必须精确地描述覆盖每个方法所带来的影响。即该类必须有文档说明其可改写的方法的自用性。
     * 对于每一个公有的或受保护的方法或者构造函数，它的文档必须指明它调用了哪些可改写的方法是以什么顺序调用，
     * 每个调用的结果是如何影响后续的处理过程的。按惯例，如果一个方法调用了可改写的方法，那么在它的文档注释的末尾应该包含关于这些调用的描述信息。
     *以这样的句子开头“Implementation Requirements,”
     * */


    /*
     * e.g  java.util.AbstractCollection:   public boolean remove(Object o)
     * 清楚说明了，覆盖iterator方法将会影响remove方法的行为。
     * 但是，这是否违背了一个良好的API文档应该描述给定的方法是什么，而不是它是如何做的呢？
     * 是的，这是继承违反封装这一事实的不幸后果。要文档说明一个类以便可以安全地进行子类化，必须描述清楚那些没有详细说明的实现细节。
     *
     * 设计继承涉及的不仅仅是文档说明自用的模式。 为了让程序员能够写出有效的子类而不会带来不适当的痛苦，
     * 类必须通过某种形式提供适当的hook，以便能够进入到它的内部工作流程中，
     * 这种形式可以是精心选择的受保护的方法，也可以是受保护的域（少见）
     * e.g：removeRange method from java.util.AbstractList:
     *
     * */


    /*
     * 那么当你设计一个继承类的时候，你如何决定暴露哪些的受保护的成员呢？
     * 不幸的是，没有灵丹妙药。 所能做的最佳途径就是努力思考，发挥最好的想象，然后编写一些子类进行测试。
     * 应该尽可能少地暴露受保护的成员，因为每个成员都表示对实现细节的承诺。
     * 另一方面，你不能暴露太少，因为失去了保护的成员会导致一个类几乎不能用于继承。
     *
     * 发布前必须编写子类对类进行测试
     * */


    /*
     * 类必须遵守允许继承的限制。 构造方法绝不能直接或间接调用可重写的方法。e.g：Sub
     * */

    /*
     * 对于一个并非为了继承而设计的非final具体类，在修改了它的内部实现之后，接受到与子类化相关的错误报告并不少见，
     * 这个问题的解决方案：对于那些并非为了安全地进行子类化而设计和编写文档的类，禁止子类化；
     * 禁止子类化的方式有：类声明为final；所有的构造器变成私有的，或者包级私有的，并增加一些共有的静态工厂来替代构造器
     *
     * 如果一个具体的类没有实现一个标准的接口，禁止继承给一些程序员带来不便。
     * 如果你觉得你必须允许从这样的类继承，一个合理的方法是确保类从不调用任何可重写的方法，
     * 并文档说明这个事实。 换句话说，完全消除类的自用（self-use）的可重写的方法。
     *  */
}
